"""
Auth Agent - Generates JWT Authentication System

Input: DB Schema output (User model), Planner config
Output: Auth routes, security utilities, model extensions

Deterministic. No AI. Pure templates.
"""

from typing import Dict, Any, List, Literal
from pydantic import BaseModel, ConfigDict


# ========== TYPES ==========

class AuthOutput(BaseModel):
    strategy: Literal["jwt", "session"] = "jwt"
    user_model: str = "User"
    routes: List[str]
    requires_hashing: bool = True
    requires_env: List[str]
    files: Dict[str, str]  # filename -> code


# ========== CODE TEMPLATES ==========

SECURITY_TEMPLATE = '''"""
Security utilities - Password hashing and JWT token management
Auto-generated by VibeCober Auth Agent
"""

from datetime import datetime, timedelta
from typing import Optional
import os
import bcrypt
import jwt

# Configuration
SECRET_KEY = os.getenv("SECRET_KEY", "your-secret-key-change-in-production")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30


def hash_password(password: str) -> str:
    """Hash password using bcrypt"""
    password_bytes = password.encode("utf-8")[:72]  # bcrypt 72-byte limit
    salt = bcrypt.gensalt()
    return bcrypt.hashpw(password_bytes, salt).decode("utf-8")


def verify_password(password: str, hashed: str) -> bool:
    """Verify password against bcrypt hash"""
    try:
        password_bytes = password.encode("utf-8")[:72]
        return bcrypt.checkpw(password_bytes, hashed.encode("utf-8"))
    except Exception:
        return False


def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """Create JWT access token"""
    to_encode = data.copy()
    expire = datetime.utcnow() + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)


def decode_token(token: str) -> Optional[dict]:
    """Decode and verify JWT token"""
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except jwt.ExpiredSignatureError:
        return None
    except jwt.InvalidTokenError:
        return None
'''


DEPENDENCIES_TEMPLATE = '''"""
Auth dependencies - FastAPI dependency injection for protected routes
Auto-generated by VibeCober Auth Agent
"""

from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.orm import Session

from .security import decode_token
from database import get_db
from models import User

security = HTTPBearer()


async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
) -> User:
    """Get current authenticated user from JWT token"""
    token = credentials.credentials
    
    payload = decode_token(token)
    if payload is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid or expired token",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    user_id = payload.get("sub")
    if user_id is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload",
        )
    
    user = db.query(User).filter(User.id == user_id).first()
    if user is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found",
        )
    
    return user


def get_optional_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: Session = Depends(get_db)
) -> User | None:
    """Get current user if authenticated, None otherwise"""
    try:
        return get_current_user(credentials, db)
    except HTTPException:
        return None
'''


ROUTES_TEMPLATE = '''"""
Auth routes - Register, Login, Profile endpoints
Auto-generated by VibeCober Auth Agent
"""

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from pydantic import BaseModel, EmailStr

from database import get_db
from models import User
from auth.security import hash_password, verify_password, create_access_token
from auth.dependencies import get_current_user

router = APIRouter(prefix="/auth", tags=["Authentication"])


# ========== Schemas ==========

class UserCreate(BaseModel):
    email: EmailStr
    password: str
    name: str


class UserLogin(BaseModel):
    email: EmailStr
    password: str


class UserResponse(BaseModel):
    model_config = ConfigDict(from_attributes=True)

    id: int
    email: str
    name: str
    is_active: bool


class Token(BaseModel):
    access_token: str
    token_type: str = "bearer"


# ========== Routes ==========

@router.post("/register", response_model=UserResponse, status_code=status.HTTP_201_CREATED)
def register(user_data: UserCreate, db: Session = Depends(get_db)):
    """Register a new user"""
    # Check if email exists
    existing = db.query(User).filter(User.email == user_data.email).first()
    if existing:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered"
        )
    
    # Create user
    user = User(
        email=user_data.email,
        password_hash=hash_password(user_data.password),
        name=user_data.name
    )
    
    db.add(user)
    db.commit()
    db.refresh(user)
    
    return user


@router.post("/login", response_model=Token)
def login(credentials: UserLogin, db: Session = Depends(get_db)):
    """Login and receive JWT token"""
    user = db.query(User).filter(User.email == credentials.email).first()
    
    if not user or not verify_password(credentials.password, user.password_hash):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    access_token = create_access_token(data={"sub": str(user.id)})
    
    return Token(access_token=access_token)


@router.get("/me", response_model=UserResponse)
def get_me(current_user: User = Depends(get_current_user)):
    """Get current authenticated user profile"""
    return current_user
'''


ENV_TEMPLATE = '''# Auth Configuration
SECRET_KEY=your-super-secret-key-change-this
ACCESS_TOKEN_EXPIRE_MINUTES=30

# Database
DATABASE_URL=sqlite:///./app.db

# App
DEBUG=true
'''


# ========== AUTH AGENT ==========

class AuthAgent:
    """
    Generates authentication system based on DB schema.
    Deterministic template-based generation.
    """
    
    def __init__(
        self,
        db_schema: Dict[str, Any],
        mode: Literal["simple", "full", "production"] = "full"
    ):
        self.db_schema = db_schema
        self.mode = mode
        self.has_user_table = self._check_user_table()
    
    def _check_user_table(self) -> bool:
        """Check if User table exists in schema"""
        tables = self.db_schema.get("schema", {}).get("tables", [])
        return any(t.get("name") == "users" for t in tables)
    
    def generate(self) -> AuthOutput:
        """Main entry - generate complete auth system"""
        if not self.has_user_table:
            # Return minimal stub if no user table
            return AuthOutput(
                strategy="jwt",
                user_model="User",
                routes=[],
                requires_hashing=False,
                requires_env=[],
                files={}
            )
        
        files = {
            "auth/security.py": SECURITY_TEMPLATE.strip(),
            "auth/dependencies.py": DEPENDENCIES_TEMPLATE.strip(),
            "auth/routes.py": ROUTES_TEMPLATE.strip(),
            ".env.example": ENV_TEMPLATE.strip(),
        }
        
        # Add __init__.py for auth package
        files["auth/__init__.py"] = '"""Auth package - JWT authentication"""'
        
        routes = ["register", "login", "me"]
        
        # Production mode adds more security
        if self.mode == "production":
            routes.extend(["refresh", "logout"])
        
        return AuthOutput(
            strategy="jwt",
            user_model="User",
            routes=routes,
            requires_hashing=True,
            requires_env=["SECRET_KEY", "ACCESS_TOKEN_EXPIRE_MINUTES"],
            files=files
        )


# ========== PUBLIC API ==========

def auth_agent(context: Dict[str, Any]) -> Dict[str, Any]:
    """
    Main entry point for orchestrator.
    
    Args:
        context: Should contain 'db_schema' output and optionally 'mode'
        
    Returns:
        Dict with auth config and generated code
    """
    db_schema = context.get("db_schema", {})
    mode = context.get("mode", "full")
    
    agent = AuthAgent(db_schema, mode=mode)
    output = agent.generate()
    
    return {
        "auth": output.model_dump(),
        "routes_count": len(output.routes),
        "files_count": len(output.files),
        "status": "success" if output.routes else "skipped"
    }


# ========== EXAMPLE USAGE ==========

if __name__ == "__main__":
    # Test with sample DB schema
    sample_db_schema = {
        "schema": {
            "tables": [
                {"name": "users", "columns": []},
                {"name": "posts", "columns": []}
            ]
        }
    }
    
    result = auth_agent({"db_schema": sample_db_schema, "mode": "full"})
    
    print("=" * 60)
    print("AUTH OUTPUT:")
    print("=" * 60)
    print(f"Strategy: {result['auth']['strategy']}")
    print(f"Routes: {result['auth']['routes']}")
    print(f"Requires Env: {result['auth']['requires_env']}")
    print(f"Files Generated: {list(result['auth']['files'].keys())}")
    
    print("\n" + "=" * 60)
    print("SECURITY.PY:")
    print("=" * 60)
    print(result['auth']['files']['auth/security.py'][:500] + "...")
