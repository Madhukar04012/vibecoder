"""
Testing Service — Phase 3

Sandbox test execution for QA Agent.
Runs tests in isolated temp directories with timeout protection.

Features:
- Fresh sandbox per run
- No state leakage
- Hard timeout (60s default)
- Supports pytest (Python) and jest (JS)

Usage:
    from backend.services.testing_service import run_tests
    result = run_tests("/path/to/project", test_code)
    # {"passed": bool, "stdout": str, "stderr": str, "errors": list}
"""

import tempfile
import subprocess
import shutil
import os
from pathlib import Path
from typing import Dict, Any, List, Optional


# ─── Constants ───────────────────────────────────────────────────────────────

DEFAULT_TIMEOUT = 60  # seconds
PYTEST_CMD = ["pytest", "-q", "--tb=short"]
JEST_CMD = ["npx", "jest", "--passWithNoTests"]


# ─── Main Test Runner ────────────────────────────────────────────────────────

def run_tests(
    project_path: str,
    test_code: str,
    timeout: int = DEFAULT_TIMEOUT,
    test_framework: str = "auto",
) -> Dict[str, Any]:
    """
    Execute tests in isolated sandbox.
    
    Args:
        project_path: Path to project directory
        test_code: Generated test code to run
        timeout: Maximum execution time in seconds
        test_framework: "pytest", "jest", or "auto" (detect from project)
    
    Returns:
        {
            "passed": bool,
            "stdout": str,
            "stderr": str,
            "errors": list[str],
            "exit_code": int
        }
    """
    sandbox = None
    
    try:
        # Create fresh sandbox
        sandbox = tempfile.mkdtemp(prefix="vibecoder_qa_")
        
        # Copy project to sandbox (if exists)
        if project_path and os.path.exists(project_path):
            shutil.copytree(project_path, sandbox, dirs_exist_ok=True)
        
        # Detect test framework
        if test_framework == "auto":
            test_framework = _detect_framework(sandbox, test_code)
        
        # Write test file
        test_file = _write_test_file(sandbox, test_code, test_framework)
        
        # Run tests
        result = _execute_tests(sandbox, test_framework, timeout)
        
        return result
        
    except subprocess.TimeoutExpired:
        return {
            "passed": False,
            "stdout": "",
            "stderr": f"Test execution timed out after {timeout}s",
            "errors": ["Timeout exceeded"],
            "exit_code": -1,
        }
    except Exception as e:
        return {
            "passed": False,
            "stdout": "",
            "stderr": str(e),
            "errors": [str(e)],
            "exit_code": -1,
        }
    finally:
        # Always cleanup sandbox
        if sandbox and os.path.exists(sandbox):
            try:
                shutil.rmtree(sandbox)
            except Exception:
                pass  # Best effort cleanup


# ─── Helper Functions ────────────────────────────────────────────────────────

def _detect_framework(sandbox: str, test_code: str) -> str:
    """Detect test framework from project or test code."""
    # Check for package.json (Node.js project)
    package_json = Path(sandbox) / "package.json"
    if package_json.exists():
        import json
        try:
            with open(package_json) as f:
                pkg = json.load(f)
                deps = {**pkg.get("dependencies", {}), **pkg.get("devDependencies", {})}
                if "jest" in deps or "@jest/core" in deps:
                    return "jest"
        except Exception:
            pass
    
    # Check for Python markers
    if any(f in test_code for f in ["import pytest", "from pytest", "def test_", "@pytest"]):
        return "pytest"
    
    # Check for Jest markers
    if any(f in test_code for f in ["describe(", "it(", "test(", "expect("]):
        return "jest"
    
    # Check for requirements.txt
    req_file = Path(sandbox) / "requirements.txt"
    if req_file.exists():
        return "pytest"
    
    # Default to pytest
    return "pytest"


def _write_test_file(sandbox: str, test_code: str, framework: str) -> str:
    """Write test code to appropriate file."""
    if framework == "jest":
        test_file = os.path.join(sandbox, "test_autogenerated.test.js")
    else:
        test_file = os.path.join(sandbox, "test_autogenerated.py")
    
    with open(test_file, "w", encoding="utf-8") as f:
        f.write(test_code)
    
    return test_file


def _execute_tests(sandbox: str, framework: str, timeout: int) -> Dict[str, Any]:
    """Execute tests using the appropriate framework."""
    if framework == "jest":
        cmd = JEST_CMD.copy()
    else:
        cmd = PYTEST_CMD.copy()
    
    # Ensure pytest is available for Python tests
    if framework == "pytest":
        # Check if pytest is installed, if not try to install it
        _ensure_pytest(sandbox)
    
    try:
        result = subprocess.run(
            cmd,
            cwd=sandbox,
            capture_output=True,
            text=True,
            timeout=timeout,
            env={**os.environ, "PYTHONPATH": sandbox},
        )
        
        passed = result.returncode == 0
        errors = _parse_errors(result.stderr, result.stdout, framework) if not passed else []
        
        return {
            "passed": passed,
            "stdout": result.stdout,
            "stderr": result.stderr,
            "errors": errors,
            "exit_code": result.returncode,
        }
        
    except FileNotFoundError:
        return {
            "passed": False,
            "stdout": "",
            "stderr": f"{framework} not found. Install it first.",
            "errors": [f"{framework} not installed"],
            "exit_code": -1,
        }


def _ensure_pytest(sandbox: str) -> None:
    """Ensure pytest is available."""
    try:
        subprocess.run(
            ["python", "-c", "import pytest"],
            capture_output=True,
            timeout=10,
        )
    except Exception:
        # Try to install pytest in sandbox
        try:
            subprocess.run(
                ["pip", "install", "pytest", "-q"],
                capture_output=True,
                timeout=30,
            )
        except Exception:
            pass


def _parse_errors(stderr: str, stdout: str, framework: str) -> List[str]:
    """Parse test errors from output."""
    errors = []
    
    if framework == "pytest":
        # Look for FAILED markers
        for line in stdout.split("\n"):
            if "FAILED" in line or "ERROR" in line:
                errors.append(line.strip())
        # Look for assertion errors
        for line in stderr.split("\n"):
            if "AssertionError" in line or "Error:" in line:
                errors.append(line.strip())
    
    elif framework == "jest":
        # Look for test failures
        for line in stdout.split("\n"):
            if "FAIL" in line or "●" in line:
                errors.append(line.strip())
    
    # If no specific errors found, use stderr
    if not errors and stderr.strip():
        errors = [stderr.strip()[:500]]
    
    return errors[:10]  # Limit to 10 errors


# ─── Convenience Functions ───────────────────────────────────────────────────

def run_python_tests(project_path: str, test_code: str) -> Dict[str, Any]:
    """Run Python tests with pytest."""
    return run_tests(project_path, test_code, test_framework="pytest")


def run_js_tests(project_path: str, test_code: str) -> Dict[str, Any]:
    """Run JavaScript tests with jest."""
    return run_tests(project_path, test_code, test_framework="jest")


def validate_test_code(test_code: str) -> Dict[str, Any]:
    """Validate test code syntax without running."""
    sandbox = None
    
    try:
        sandbox = tempfile.mkdtemp(prefix="vibecoder_validate_")
        framework = "pytest" if "import pytest" in test_code or "def test_" in test_code else "jest"
        
        test_file = _write_test_file(sandbox, test_code, framework)
        
        if framework == "pytest":
            result = subprocess.run(
                ["python", "-m", "py_compile", test_file],
                capture_output=True,
                text=True,
                timeout=10,
            )
        else:
            # For JS, we just check syntax
            result = subprocess.CompletedProcess(args=[], returncode=0)
        
        return {
            "valid": result.returncode == 0,
            "errors": [result.stderr] if result.returncode != 0 else [],
        }
        
    except Exception as e:
        return {"valid": False, "errors": [str(e)]}
    
    finally:
        if sandbox and os.path.exists(sandbox):
            try:
                shutil.rmtree(sandbox)
            except Exception:
                pass
